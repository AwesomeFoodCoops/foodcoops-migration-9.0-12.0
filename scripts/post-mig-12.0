#!/usr/bin/env python
from __future__ import print_function
import click
import click_odoo
from config import *

import logging
_logger = logging.getLogger(__name__)


def _report_modules_states(env):
    # Modules to install
    modules = env['ir.module.module'].search([
        ('state', '=', 'to install')])
    if modules:
        _logger.warning(
            '\n\nModules to install:\n%s' % '\n'.join(modules.mapped('name')))
    # Modules to update
    modules = env['ir.module.module'].search([
        ('state', '=', 'to upgrade')])
    if modules:
        _logger.warning(
            '\n\nModules to update:\n%s' % '\n'.join(modules.mapped('name')))
    # Modules to remove
    modules = env['ir.module.module'].search([
        ('state', '=', 'to remove')])
    if modules:
        _logger.warning(
            '\n\nModules to remove:\n%s' % '\n'.join(modules.mapped('name')))


def _upgrade_modules(env):
    '''
    Upgrade all installed modules, with exception
    of those that we plan to uninstall, because we
    may not have them in the sources.

    Idea is we upgrade modules first, so that our
    dependency tree no longer depends on modules
    that are planned to be uninstalled.
    '''
    ir_module = env['ir.module.module']
    modules_to_uninstall = (
        MODULES_TO_UNINSTALL
        + MODULES_PENDING_MIGRATION
        + [i[0] for i in MODULES_TO_REPLACE]
    )
    modules = ir_module.search([
        ('state', 'in', ['to upgrade']),
        ('name', 'not in', modules_to_uninstall)])
    if modules:
        _logger.info('Upgrading modules: %s', modules.mapped('name'))
        modules.button_immediate_upgrade()


def _uninstall_modules(env):
    '''
    Uninstall all planned to uninstall modules.
    Some modules on this list might already have
    been uninstalled by pre-clean.

    But it's ok, we check again and if they're
    present we remove them.
    '''
    ir_module = env['ir.module.module']

    modules_to_uninstall = (
        MODULES_TO_UNINSTALL
        + MODULES_PENDING_MIGRATION
        + [i[0] for i in MODULES_TO_REPLACE]
    )

    module_ids = ir_module.search([
        ('name', 'in', modules_to_uninstall),
        ('state', 'in', ['installed', 'to upgrade', 'to remove']),
    ])

    # Force installed state
    # Because odoo won't uninstall modules in 'to upgrade' state
    module_ids.write({'state': 'installed'})
    _logger.info('Uninstalling modules: %s' % module_ids.mapped('name'))
    module_ids.button_immediate_uninstall()


def _install_modules(env):
    '''
    Install all planned to install modules
    '''
    ir_module = env['ir.module.module']
    modules_to_install = (
        MODULES_TO_INSTALL
        + [i[1] for i in MODULES_TO_REPLACE]
    )

    module_ids = env['ir.module.module'].search([
        ('name', 'in', modules_to_install)])

    missing_modules = set(modules_to_install) - set(module_ids.mapped('name'))
    if missing_modules:
        _logger.error(
            'Trying to install modules that are missing: '
            '%s' % missing_modules)

    _logger.info('Installing modules: %s' % module_ids.mapped('name'))
    module_ids.button_immediate_install()


def _apply_post_fixes(env):
    '''
    Post migration required by some modules
    TODO: Move this to a separate file
    '''

    # Fix modules left in inconsistent states
    module_ids = env['ir.module.module'].search([
        ('state', 'in', ['to upgrade'])])
    module_ids.write({'state': 'installed'})

    # pos_payment_terminal: field renamed
    env.cr.execute("""
        UPDATE account_journal SET pos_terminal_payment_mode = payment_mode;
    """)

    # coop_default_pricetag: field renamed
    env.cr.execute("""
        UPDATE product_template SET print_category_id = category_print_id
    """)

    # TODO: reset login of admin and system
    env.ref('base.user_admin').write({'login': 'admin'})
    env.ref('base.user_root').write({'login': '__system__'})

    # Display name of categories not considering languages
    # https://www.druidoo.io/web#id=2149&action=367&model=project.task&view_type=form&menu_id=237
    env['product.category'].search([])._compute_complete_name()

    # Reload translations terms
    _logger.info('Reloading translation terms..')
    langs = [l[0] for l in env['res.lang'].get_installed()]
    modules = env['ir.module.module'].search([('state', '=', 'installed')])
    modules.with_context(overwrite=True)._update_translations(langs)
    env.cr.execute('ANALYZE ir_translation')


def _apply_configs(env):
    '''
    Applies configurations needed in 12.0
    '''
    company_ids = env['res.company'].search([])
    pos_configs = env['pos.config'].search([])

    # Pos configurations
    for config in pos_configs:
        if config.pricelist_id:
            config.write(
                {
                    'use_pricelist': True,
                    'available_pricelist_ids': [(4, config.pricelist_id.id)],
                }
            )

    # web_m2x_options config
    param = env['ir.config_parameter'].sudo().set_param(
        'web_m2x_options.create', 'False')

    # Configure account_check_deposit to validate moves automatically
    company_ids.write({'check_deposit_post_move': True})

    # Set default report layout
    company_ids.write({
        'external_report_layout_id': env.ref('web.external_layout_boxed').id,
    })


@click.command()
@click_odoo.env_options(default_log_level='error')
def main(env):
    _logger.info('Starting post clean..')
    ir_module = env['ir.module.module']
    ir_module.update_list()
    _logger.info('Module list updated...')

    _upgrade_modules(env)
    _uninstall_modules(env)
    _install_modules(env)

    # Almost ready, time for last minute fixes and config setup
    _apply_post_fixes(env)
    _apply_configs(env)


if __name__ == '__main__':
    main()
